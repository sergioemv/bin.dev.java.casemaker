/* Generated By:JavaCC: Do not edit this line. VisioImport.java */
package bi.view.businessrulesviews.brimport.visioparser;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.io.Reader;

import model.visioimport.ConstraintObject;
import model.visioimport.FlowObject;
import model.visioimport.RelationObject;
import model.visioimport.StateObject;
import model.visioimport.WorkFlowObject;
import bi.view.businessrulesviews.brimport.CMBRVisioImporter;

public class VisioImport implements VisioImportConstants {

private CMBRVisioImporter importer;
public CMBRVisioImporter getImporter(){
        if (importer == null)
                importer = new CMBRVisioImporter();
        return importer;
}
public void setImporter(CMBRVisioImporter importer){
        this.importer = importer;
}

public static void main(String args[]) throws ParseException {
    FileReader fileReader = null;
    Reader reader = null;

    File file= new File("");

      System.out.println("Reading from standard input...");
      System.out.print("Enter File Path:");
      try{

          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

           file=new File(br.readLine());

          }catch(Exception e){ e.printStackTrace();}

      try {
                fileReader = new FileReader(file);
        } catch (FileNotFoundException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
        }
                reader = new BufferedReader(fileReader);
                VisioImport parser = new VisioImport(reader);
                parser.start();
//		System.out.println(visioImportManager.getCurrentWorkFlow().toString());//		visioImportManager.setOutGoingFlowForEachState();//		System.out.println(visioImportManager.getBusinessRulesFromWorkFlowObject());

  }

  final public void start() throws ParseException {
    label_1:
    while (true) {
      page();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BEGINPAGE:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(0);
  }

  final public void page() throws ParseException {
    jj_consume_token(BEGINPAGE);
    jj_consume_token(SEMICOLON);
    pageName();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BEGININISTATE:
      case BEGINFINALSTATE:
      case BEGINSTATE:
      case BEGINTRANSITION:
      case BEGINCONSTRAINT:
      case BEGINRELATION:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BEGININISTATE:
        initialState();
        break;
      case BEGINSTATE:
        state();
        break;
      case BEGINTRANSITION:
        transition();
        break;
      case BEGINCONSTRAINT:
        constraint();
        break;
      case BEGINRELATION:
        relation();
        break;
      case BEGINFINALSTATE:
        finalState();
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(ENDPAGE);
    jj_consume_token(SEMICOLON);
  }

  final public void pageName() throws ParseException {
 Token t;
    jj_consume_token(PAGENAME);
    jj_consume_token(DOTS);
    t = jj_consume_token(VALUES);
    jj_consume_token(SEMICOLON);
                WorkFlowObject workFlowObject=getImporter().createWorkFlowObject(t.image.trim());
                getImporter().setCurrentWorkFlow(workFlowObject);
                getImporter().addWorkFlowObject(workFlowObject);
  }

  final public void initialState() throws ParseException {
 String name;
int id;
    jj_consume_token(BEGININISTATE);
    jj_consume_token(SEMICOLON);
    name = type();
    id = id();
    jj_consume_token(ENDINISTATE);
    jj_consume_token(SEMICOLON);
                StateObject l_StateObject= getImporter().createStateObject(name.trim(),id,null);
                getImporter().addStateObjectToCurrentDiagram(l_StateObject);
  }

  final public void state() throws ParseException {
 String name;
int id;
Token t;
    jj_consume_token(BEGINSTATE);
    jj_consume_token(SEMICOLON);
    name = type();
    id = id();
    jj_consume_token(BUSINESSACTION);
    jj_consume_token(EQUALS);
    t = jj_consume_token(VALUES);
    jj_consume_token(SEMICOLON);
    jj_consume_token(ENDSTATE);
    jj_consume_token(SEMICOLON);
        StateObject l_StateObject=getImporter().createStateObject(name.trim(),id,t.image.trim());
                getImporter().addStateObjectToCurrentDiagram(l_StateObject);
  }

  final public void constraint() throws ParseException {
int id;
String state="";
int riskLevel=-1;
String reqs="";
String values="";
    jj_consume_token(BEGINCONSTRAINT);
    jj_consume_token(SEMICOLON);
    id = id();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STATECONSTRAINT:
      case RISKLEVELCONSTRAINT:
      case REQUIREMENTSCONSTRAINT:
      case RESULTCONSTRAINT:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STATECONSTRAINT:
        state = stateConstraint();
        break;
      case RISKLEVELCONSTRAINT:
        riskLevel = riskLevelConstraint();
        break;
      case REQUIREMENTSCONSTRAINT:
        reqs = requirementConstraints();
        break;
      case RESULTCONSTRAINT:
        values = resultConstraint();
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(ENDCONSTRAINT);
    jj_consume_token(SEMICOLON);
                ConstraintObject constraintObject=getImporter().createConstraintObject(id,state,riskLevel,reqs,values);
                getImporter().addConstraintObjectToCurrentDiagram(constraintObject);
  }

  final public String stateConstraint() throws ParseException {
 Token t;
String temp="";
    jj_consume_token(STATECONSTRAINT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
      jj_consume_token(EQUALS);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    t = jj_consume_token(STATEVALUE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
                {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public int riskLevelConstraint() throws ParseException {
 Token t;
int value = -1;
    jj_consume_token(RISKLEVELCONSTRAINT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
      jj_consume_token(EQUALS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER:
        t = jj_consume_token(NUMBER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
          break;
        default:
          jj_la1[7] = jj_gen;
          ;
        }
                 value = Integer.parseInt(t.image);
        break;
      case VALUES:
        t = jj_consume_token(VALUES);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
          break;
        default:
          jj_la1[8] = jj_gen;
          ;
        }
                 value = Integer.parseInt(getImporter().deleteQuotes(t.image));
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case NUMBER:
      t = jj_consume_token(NUMBER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
         value = Integer.parseInt(t.image);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final public String requirementConstraints() throws ParseException {
 Token t;
String temp="";
    jj_consume_token(REQUIREMENTSCONSTRAINT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
      jj_consume_token(EQUALS);
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    t = jj_consume_token(OPENBRACKET);
         temp+=t.image;
    t = jj_consume_token(VALUES);
         temp+=t.image;
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_4;
      }
      t = jj_consume_token(COMMA);
         temp+=t.image;
      t = jj_consume_token(VALUES);
         temp+=t.image;
    }
    t = jj_consume_token(CLOSEBRACKET);
         temp+=t.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
                {if (true) return temp.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String resultConstraint() throws ParseException {
 Token t;
String temp="";
    jj_consume_token(RESULTCONSTRAINT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
      jj_consume_token(EQUALS);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    t = jj_consume_token(OPENBRACKET);
         temp+=t.image;
    t = jj_consume_token(STRINGS);
         temp+=text(t.image);
    t = jj_consume_token(EQUALS);
         temp+=t.image;
    t = jj_consume_token(VALUES);
         temp+=t.image;
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_5;
      }
      t = jj_consume_token(COMMA);
                 temp+=t.image;
      t = jj_consume_token(STRINGS);
                 temp+=text(t.image);
      t = jj_consume_token(EQUALS);
                 temp+=t.image;
      t = jj_consume_token(VALUES);
                 temp+=t.image;
    }
    t = jj_consume_token(CLOSEBRACKET);
         temp+=t.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
                {if (true) return temp;}
    throw new Error("Missing return statement in function");
  }

  final public void transition() throws ParseException {
 Token t;
 String startPoint;
 String endPoint;
    jj_consume_token(BEGINTRANSITION);
    jj_consume_token(SEMICOLON);
    jj_consume_token(TRANSITION);
    jj_consume_token(EQUALS);
    t = jj_consume_token(VALUES);
    jj_consume_token(SEMICOLON);
    startPoint = startPoint();
    endPoint = endPoint();
    jj_consume_token(ENDTRANSITION);
    jj_consume_token(SEMICOLON);
                FlowObject l_FlowObject=getImporter().createFlowObject(t.image.trim(),startPoint.trim(),endPoint.trim());
                getImporter().addFlowObjectToCurrentDiagram(l_FlowObject);
  }

  final public void relation() throws ParseException {
 String startPoint;
 String endPoint;
    jj_consume_token(BEGINRELATION);
    jj_consume_token(SEMICOLON);
    startPoint = startPoint();
    endPoint = endPoint();
    jj_consume_token(ENDRELATION);
    jj_consume_token(SEMICOLON);
                RelationObject relationObject=getImporter().createRelationObject(startPoint.trim(),endPoint.trim());
                getImporter().addRelationToCurrentDiagram(relationObject);
  }

  final public void finalState() throws ParseException {
 String name;
int id;
    jj_consume_token(BEGINFINALSTATE);
    jj_consume_token(SEMICOLON);
    name = type();
    id = id();
    jj_consume_token(ENDFINALSTATE);
    jj_consume_token(SEMICOLON);
        StateObject l_StateObject=getImporter().createStateObject(name.trim(),id,null);
                getImporter().addStateObjectToCurrentDiagram(l_StateObject);
  }

  final public String type() throws ParseException {
 Token t;
    jj_consume_token(TYPE);
    jj_consume_token(EQUALS);
    t = jj_consume_token(VALUES);
    jj_consume_token(SEMICOLON);
                {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public int id() throws ParseException {
 Token t;
    jj_consume_token(ID);
    jj_consume_token(EQUALS);
    t = jj_consume_token(NUMBER);
    jj_consume_token(SEMICOLON);
         {if (true) return new Integer(t.image).intValue();}
    throw new Error("Missing return statement in function");
  }

  final public String startPoint() throws ParseException {
 Token t;
    jj_consume_token(BEGIN);
    jj_consume_token(EQUALS);
    t = jj_consume_token(VALUES);
    jj_consume_token(SEMICOLON);
         {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public String endPoint() throws ParseException {
 Token t;
    jj_consume_token(END);
    jj_consume_token(EQUALS);
    t = jj_consume_token(VALUES);
    jj_consume_token(SEMICOLON);
         {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public String text(String string) throws ParseException {
        StringBuffer result=new StringBuffer();
        Token t;
                result.append(string);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRINGS:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_6;
      }
      t = jj_consume_token(STRINGS);
                        result.append(t.image);
    }
                {if (true) return result.toString();}
    throw new Error("Missing return statement in function");
  }

  public VisioImportTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[19];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x80,0x40449000,0x40449000,0x0,0x0,0x200000,0x800,0x800,0x800,0x28000000,0x800,0x8200000,0x200000,0x0,0x800,0x200000,0x0,0x800,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x1,0x1,0x3c,0x3c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x200,0x0,0x400,};
   }

  public VisioImport(java.io.InputStream stream) {
     this(stream, null);
  }
  public VisioImport(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new VisioImportTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
  }

  public VisioImport(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new VisioImportTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
  }

  public VisioImport(VisioImportTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
  }

  public void ReInit(VisioImportTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[43];
    for (int i = 0; i < 43; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 19; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 43; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
