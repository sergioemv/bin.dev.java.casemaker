/* Generated By:JavaCC: Do not edit this line. AmericanParser.java */
package bi.controller.tdparser.american;

import bi.view.utils.CMIntervalValue;
import java.lang.StringBuffer;
import java.util.Vector;
import java.text.NumberFormat;
import java.text.DecimalFormat;
import java.util.Locale;
import bi.controller.VariablesManager;
import bi.view.mainframeviews.CMApplication;
import org.apache.log4j.Logger;

public class AmericanParser implements AmericanParserConstants {
    private StringBuffer stringAcumulator;
    private Vector<String> intervalValues = new Vector<String>();
    private Vector<CMIntervalValue> intervalToExtraValue= new Vector<CMIntervalValue>();
    private String writeFormat;

    public Vector getIntervalValues() {
        return intervalValues;
    }

    public Vector getIntervalsToExtraValue() {
                return intervalToExtraValue;
        }

    public String getstringAcumulator() {
        return stringAcumulator.toString();
    }

    public String calculateValueOfRange(String operLog, String number) {
        int p = 0;
        if (operLog.equals(">") || operLog.equals("<>") || operLog.equals("!="))
            p = 1;
        else if (operLog.equals("<"))
            p = -1;
        if (p != 0) {
            String numberToFloat = convertNumberInFloat(number);
            if (numberToFloat.indexOf(".") >= 0) {
                float add = calculateNumOfDecimal(numberToFloat, p);
                float result = Float.parseFloat(numberToFloat);
                result = result + add;
                //NumberFormat nf = NumberFormat.getNumberInstance(new Locale("de", "DE"));
                NumberFormat nf = NumberFormat.getNumberInstance(Locale.GERMANY);
                DecimalFormat myFormatter = (DecimalFormat)nf;
                myFormatter.applyPattern(writeFormat);
                String output = myFormatter.format(result);
                number = output; //Float.toString(result);
                CMIntervalValue intervalValue= new CMIntervalValue();
                intervalValue.setNumber(new Float(result));
                intervalValue.setLocale(new Locale("de", "DE"));
                intervalValue.setDiff(new Float(-add));
                intervalValue.setWriteFormat(writeFormat);
                intervalToExtraValue.addElement(intervalValue);
            }
            else {
                int result = Integer.parseInt(numberToFloat);
                result = result + p;
                //NumberFormat nf = NumberFormat.getNumberInstance(Locale.GERMANY);
                //DecimalFormat myFormatter = (DecimalFormat)nf;
                //myFormatter.applyPattern(writeFormat);
                //String output = myFormatter.format(result);
                number = (new Integer(result)).toString(); //Integer.toString(result);
                CMIntervalValue intervalValue= new CMIntervalValue();
                intervalValue.setNumber(new Integer(result));
                intervalValue.setLocale(Locale.GERMANY);
                intervalValue.setDiff(new Integer(-p));
                intervalValue.setWriteFormat(writeFormat);
                intervalToExtraValue.addElement(intervalValue);
            }
       }
       else{
                String numberToFloat=convertNumberInFloat(number);
            if(numberToFloat.indexOf(".")>=0){
                float  result=Float.parseFloat(numberToFloat);
                float add=calculateNumOfDecimal(numberToFloat, 1);
                CMIntervalValue intervalValue= new CMIntervalValue();
                intervalValue.setNumber(new Float(result));
                intervalValue.setLocale(Locale.GERMANY);
                if(operLog.indexOf(">") >= 0){
                        intervalValue.setDiff(new Float(-add));
                }
                else{
                        intervalValue.setDiff(new Float(Math.abs(add)));
                }
                intervalValue.setWriteFormat(writeFormat);
                intervalToExtraValue.addElement(intervalValue);
            }
            else{
                int result=Integer.parseInt(numberToFloat);
                CMIntervalValue intervalValue= new CMIntervalValue();
                intervalValue.setNumber(new Integer(result));
                intervalValue.setLocale(Locale.GERMANY);
                if(operLog.indexOf(">") >= 0){
                        intervalValue.setDiff(new Integer(-1));
                }
                else{
                        intervalValue.setDiff(new Integer(Math.abs(1)));
                }
                intervalValue.setWriteFormat(writeFormat);
                intervalToExtraValue.addElement(intervalValue);
            }

        }
        return number;
    }

    public String convertNumberInFloat(String number) {
        if (number.indexOf(".") >= 0 /*&& number.indexOf(",")>=0*/) {
            writeFormat = "###,###.#";
        }
        else {
                /*if(number.indexOf(".")>=0){
			writeFormat="###,###";
		}
		else{
			if(number.indexOf(",")>=0)*/

            writeFormat = "###,#";

                        /*else
			writeFormat="###";
		}*/
        }
        while (number.indexOf(".") >= 0) {
            number = number.replace('.', '#');
        }
        number = number.replaceAll("#", "");
        number = number.replaceAll(",", ".");
        return number;
    }

    public float calculateNumOfDecimal(String numFloat, int dif) {
        String decimals = numFloat.substring(numFloat.indexOf(".") + 1, numFloat.length());
        int cant = decimals.length();
        StringBuffer result;
        if (cant > 0) {
            if (dif < 0)
                result = new StringBuffer("-0.");
            else
                result = new StringBuffer("0.");
            for (int i = 1; i < cant; i++) {
                result.append("0");
                writeFormat = writeFormat + "#";
            }
            if (dif == 0)
                result.append("0");
            else
                result.append("1");
            Logger.getLogger(this.getClass()).debug(result.toString());
            return Float.parseFloat(result.toString());
        }
        else {
            if (dif < 0)
                return -1f;
            else
                return 1f;
        }
    }

  final public void start() throws ParseException {
        intervalValues = new Vector<String>();
    formalPolicy();
    jj_consume_token(0);
  }

  final public void formalPolicy() throws ParseException {
    content();
  }

  final public void content() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MAY:
    case MEN:
    case MAYIGUAL:
    case MENIGUAL:
    case DIF:
    case DIFALT:
      interval();
      break;
    case BRACKETOPEN:
    case BRACKETCLOSE:
      mathInval();
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void interval() throws ParseException {
    range();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AND:
      difInterval();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
  }

  final public void difInterval() throws ParseException {
    thirhDifInterval();
  }

  final public void thirhDifInterval() throws ParseException {
    jj_consume_token(AND);
    range();
  }

  final public String expresion() throws ParseException {
        Token t = new Token();
        String blank = " ";
        String result;
    t = jj_consume_token(STRINGS);
    // text()
    
                result = text(t.image);
                //blank = blank + t.image;
                blank = blank + result;
                {if (true) return blank;}
    throw new Error("Missing return statement in function");
  }

  final public void range() throws ParseException {
        String operLog;
    operLog = logicOper();
    range2(operLog);
  }

  final public void range2(String operLog) throws ParseException {
                String number;
        String expresion = "";
        Token t;
        String var;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      t = jj_consume_token(INTEGER);
                        number = t.image;
                number = calculateValueOfRange(operLog, number);
      break;
    case REALNUMBER:
      t = jj_consume_token(REALNUMBER);
                number = t.image;
                number = calculateValueOfRange(operLog, number);
      break;
    case Variable:
      var = variables();
                        number = var;
                number = calculateValueOfRange(operLog, number);
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRINGS:
      expresion = expresion();
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
                ((CMIntervalValue)intervalToExtraValue.lastElement()).setExpresion(expresion);
                intervalValues.addElement(number + expresion);
  }

  final public void mathInval() throws ParseException {
        String firstBracket;
        String secondBracket;
        String operLogic = "";
        String number;
    firstBracket = brackets();
    number = contInterval();
                if (firstBracket.equals("["))
                operLogic = ">=";
                else
                operLogic = ">";
                intervalValues.addElement(calculateValueOfRange(operLogic, number));
    jj_consume_token(COMA);
    number = contInterval();
    secondBracket = brackets();
                if (secondBracket.equals("]"))
                operLogic = "<=";
                else
                operLogic = "<";
                intervalValues.addElement(calculateValueOfRange(operLogic, number));
  }

  final public String contInterval() throws ParseException {
            Token t;
        String value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARTOPEN:
      jj_consume_token(PARTOPEN);
      value = cont();
      jj_consume_token(PARTCLOSE);
                {if (true) return value;}
      break;
    case INTEGER:
      t = jj_consume_token(INTEGER);
                {if (true) return t.image;}
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String cont() throws ParseException {
        Token t;
        String var;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      t = jj_consume_token(INTEGER);
                {if (true) return t.image;}
      break;
    case REALNUMBER:
      t = jj_consume_token(REALNUMBER);
                {if (true) return t.image;}
      break;
    case Variable:
      var = variables();
                {if (true) return var;}
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String brackets() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BRACKETOPEN:
      t = jj_consume_token(BRACKETOPEN);
      break;
    case BRACKETCLOSE:
      t = jj_consume_token(BRACKETCLOSE);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public String parenthesis() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARTOPEN:
      t = jj_consume_token(PARTOPEN);
      break;
    case PARTCLOSE:
      t = jj_consume_token(PARTCLOSE);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public String logicOper() throws ParseException {
         Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MAY:
      t = jj_consume_token(MAY);
      break;
    case MEN:
      t = jj_consume_token(MEN);
      break;
    case MAYIGUAL:
      t = jj_consume_token(MAYIGUAL);
      break;
    case MENIGUAL:
      t = jj_consume_token(MENIGUAL);
      break;
    case DIF:
      t = jj_consume_token(DIF);
      break;
    case DIFALT:
      t = jj_consume_token(DIFALT);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public String text(String string) throws ParseException {
        StringBuffer result=new StringBuffer();
        Token t;
                result.append(string);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRINGS:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_1;
      }
      t = jj_consume_token(STRINGS);
                        result.append(t.image);
    }
                {if (true) return result.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String variables() throws ParseException {
        String result;
        Token t;
        String temp;
    t = jj_consume_token(Variable);
                result = t.image;
    t = jj_consume_token(STRINGS);
    temp = text(t.image);
                result = result+temp;
                String tempResult = VariablesManager.returnImplicitExplicitVariable(result,CMApplication.frame.getGridTDStructure().getTDStructure());
                if(!tempResult.equalsIgnoreCase("")){
                        {if (true) return tempResult;}
                }
                else{
                        {if (true) return result;}
                }
    throw new Error("Missing return statement in function");
  }

  public AmericanParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[10];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x1fb00,0x80000,0x300080,0x40000000,0x120000,0x300080,0x18000,0x60000,0x7b00,0x40000000,};
   }

  public AmericanParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public AmericanParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new AmericanParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  public AmericanParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AmericanParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  public AmericanParser(AmericanParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  public void ReInit(AmericanParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[31];
    for (int i = 0; i < 31; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 10; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 31; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
