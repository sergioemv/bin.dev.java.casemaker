/**
 * Developed by BUSINESS SOFTWARE INNOVATIONS. .
 * Copyright (c)2003 Díaz und Hilterscheid Unternehmensberatung. All rights reserved.
 * This File contains the Tokens and GRammar for Interval Time Parser
 */
options {
    // do not remove or modify the following 5 lines:
    STATIC = false; // more instances of the token manager will be allowed
    //USER_CHAR_STREAM = true; // user provided CharStream
    BUILD_PARSER = true; // do not build parser
    BUILD_TOKEN_MANAGER = true; // build token manager
   // UNICODE_INPUT = true; // input will be unicode characters
}

PARSER_BEGIN(IntervalTimeParser)
package bi.controller.tdparser.intervaltimeparser;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Vector;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.text.Format;
import bi.controller.VariablesManager;
import bi.view.mainframeviews.CMApplication;
import bi.view.utils.CMIntervalValue;
import java.util.Locale;

public class IntervalTimeParser{
       private StringBuffer stringAcumulator;
        private Vector intervalValues= new Vector();
        private Vector intervalToExtraValue= new Vector();
        public Vector getIntervalValues(){
                return intervalValues;
        }

        public Vector getIntervalToExtraValue() {
        	return intervalToExtraValue;
        }

        public String getstringAcumulator(){
                return stringAcumulator.toString();
        }
        public String calculateValueOfRange(long p_Time, int p_Variant, String  p_Format){
                //p_Time= p_Time+p_Variant;
                Date date= Calendar.getInstance().getTime();
                date.setTime(p_Time);
                GregorianCalendar calendar=new GregorianCalendar();
                calendar.setTime(date);
                if(p_Format.equals("HH:mm"))
                        calendar.add(Calendar.MINUTE, p_Variant);
                else
                        calendar.add(Calendar.SECOND, p_Variant);
                Format formatter;
                formatter = new SimpleDateFormat(p_Format);
        String result = formatter.format(calendar.getTime());
        	CMIntervalValue intervalValue= new CMIntervalValue();
        	intervalValue.setNumber(new Long(calendar.getTimeInMillis()));
        	intervalValue.setLocale(new Locale("de", "DE"));
        	//intervalValue.setDiff(new Float(-p_Variant));
        	intervalValue.setWriteFormat(p_Format);
        	intervalToExtraValue.addElement(intervalValue);
                return result;
    }

        public String deleteParenthesis(String p_Value){
                p_Value=p_Value.replace('(',' ');
                p_Value=p_Value.replace(')',' ');
                return p_Value.trim();
        }
}

PARSER_END(IntervalTimeParser)

SKIP  : {" "| "\t"| "\n"| "\r"| "\f" | "\r\n" }
TOKEN : {<Coma : ",">}
TOKEN : {<OpenBracket : "[">}
TOKEN : {<CloseBracket: "]">}
TOKEN : {<Hour: (<FirstHours><Number><DoublePoint><MinutesNumber><Number>(<DoublePoint><MinutesNumber><Number>)?) | (<SecondHours><LastHours><DoublePoint><MinutesNumber><Number>(<DoublePoint><MinutesNumber><Number>)?)>
		 | <#FirstHours: ["0"-"1"]>
		 | <#SecondHours: "2">
		 | <#Number : ["0"-"9"]>
		 | <#LastHours : ["0"-"3"]>
		 | <#DoublePoint : ":">
		 | <#MinutesNumber : ["0"-"5"]>
		}
TOKEN : {<Variable: "$">}

TOKEN: {<May : ">" >}
TOKEN: {<Men : "<" >}
TOKEN: {<Igual : "=" >}
TOKEN: {<MayIgual : <May><Igual> >}
TOKEN: {<MenIgual : <Men><Igual> >}
TOKEN: {<AND:"and" | "AND" | "And">}
TOKEN:{<STRINGS: ~[]>}
//TOKEN: {<STRINGS: (["a"-"z","A"-"Z","0"-"9"," ","-","_"])*>}
void start():
{}
{
	{
		
		stringAcumulator= new StringBuffer();
		intervalValues= new Vector();
	}
	formalPolicy() 
	<EOF>
}
void formalPolicy():
{}
{
       formalIntervalTime() | mathIntervalTime()
}

void mathIntervalTime():
{}
{
	range()(mathIntervalTime2())?
}
void mathIntervalTime2():
{}
{
	<AND>range()|range()
}

void range():
{
	String var;
	String operLog;
	String number;
	Token t;
	int variant=0;
	long time;
	DateFormat formatter;
	String format;
	Date date;
	CMIntervalValue intervalValue;
}
{
	operLog=logicOper()
	{
		if(operLog.equals(">"))
			variant=1;
		else
			if(operLog.equals("<"))
				variant= -1;
			else
				variant=0;
	}
	(t=<Hour> 
	{
		
		format="HH:mm:ss";
		if(t.image.length()== 5)
			format="HH:mm";
		formatter= new SimpleDateFormat(format);
        date = Calendar.getInstance().getTime();
		try {
			date = (Date)formatter.parse(t.image);
		} catch (java.text.ParseException e) {
			e.printStackTrace();
		}
		time=date.getTime();
		intervalValues.addElement(calculateValueOfRange(time,variant,format));
		intervalValue=(CMIntervalValue)intervalToExtraValue.lastElement();
	}
	| var=variables()
	{
		
		format="HH:mm:ss";
		if(var.length()== 5)
			format="HH:mm";
		formatter= new SimpleDateFormat(format);
        date = Calendar.getInstance().getTime();
		try {
			date = (Date)formatter.parse(var);
		} catch (java.text.ParseException e) {
			//e.printStackTrace();
			throw new ParseException();
		}
		time=date.getTime();
		intervalValues.addElement(calculateValueOfRange(time,variant,format));
		intervalValue=(CMIntervalValue)intervalToExtraValue.lastElement();
	})
}

void formalIntervalTime():
{
	String firstBracket;
	String secondBracket;
	Token t;
	long time;
	int variant=0;
	DateFormat formatter;
	String format;
	Date date;
	String var;
	CMIntervalValue intervalValue;
}
{
	firstBracket=brackets()
	{
		if(firstBracket.equals("["))
			variant=0;
		else
			variant=-1;
	}
	(t=<Hour>
	{
		format="HH:mm:ss";
		if(t.image.length()== 5)
			format="HH:mm";
		
		formatter= new SimpleDateFormat(format);
        date = Calendar.getInstance().getTime();
		try {
			date = (Date)formatter.parse(t.image);
		} catch (java.text.ParseException e) {
			e.printStackTrace();
		}
		time=date.getTime();
		intervalValues.addElement(calculateValueOfRange(time,variant,format));
		intervalValue=(CMIntervalValue)intervalToExtraValue.lastElement();
                intervalValue.setDiff(new Integer(-1));
	}
	 | var=variables()
	 {
		format="HH:mm:ss";
		if(var.length()== 5)
			format="HH:mm";
		
		formatter= new SimpleDateFormat(format);
        date = Calendar.getInstance().getTime();
		try {
			date = (Date)formatter.parse(var);
		} catch (java.text.ParseException e) {
			//e.printStackTrace();
			throw new ParseException();
		}
		time=date.getTime();
		intervalValues.addElement(calculateValueOfRange(time,variant,format));
		intervalValue=(CMIntervalValue)intervalToExtraValue.lastElement();
                intervalValue.setDiff(new Integer(-1));
	})
	<Coma>
	(t=<Hour>
	{
		format="HH:mm:ss";
		if(t.image.length()== 5)
			format="HH:mm";
		try {
			formatter= new SimpleDateFormat(format);
			date = (Date)formatter.parse(t.image);
		} catch (java.text.ParseException e) {
			e.printStackTrace();
		}
		time=date.getTime();
	}
	 | var=variables()
	 	{
		format="HH:mm:ss";
		if(var.length()== 5)
			format="HH:mm";
		try {
			formatter= new SimpleDateFormat(format);
			date = (Date)formatter.parse(var);
		} catch (java.text.ParseException e) {
			//e.printStackTrace();
			throw new ParseException();
		}
		time=date.getTime();
	})
	secondBracket=brackets()
	{
		if(secondBracket.equals("]"))
			variant=0;
		else
			variant=-1;
		intervalValues.addElement(calculateValueOfRange(time,variant,format));
		                intervalValue=(CMIntervalValue)intervalToExtraValue.lastElement();
                intervalValue.setDiff(new Integer(1));
	}
	
}

String brackets():
{
	Token t;
}
{
	(t=<OpenBracket> | t= <CloseBracket>)	
	{
		return t.image;
	}
}

String logicOper():
{
	Token t;
}
{
	(t=<May> | t= <Men> | t=<Igual> | t=<MayIgual> | t=<MenIgual>)	
	{
		return t.image;
	}

}

String variables():
{
	String result;
	Token t;
	String temp;
}
{
	t=<Variable>
	{
		result = t.image;
	}
	t = <STRINGS>
	temp = text(t.image)
	{
		result = result+temp;
		String tempResult = VariablesManager.returnImplicitExplicitVariable(result,CMApplication.frame.getGridTDStructure().getTDStructure());
		if(!tempResult.equalsIgnoreCase("")){
			return tempResult;
		}	
		else{
			return result;
		}
	}
}
 
String text(String string):
{
	StringBuffer result=new StringBuffer();
	Token t;
}
{
	{
		result.append(string);
	}
	(t=<STRINGS>
		{
			result.append(t.image);
		}
	)*
	{
		return result.toString();
	}	
} 


